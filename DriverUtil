Driver utils

package com.svb.drivers;

import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.junit.Assert;
import org.openqa.selenium.*;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.*;

import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;


public class DriverUtilities {

    private long DEFAULT_TIMEOUT = 30;
    private long POLLING_TIME_ONE_SECOND = 1;
    private long POLLING_TIME = 5;
    private static Logger logger = LogManager.getLogger(DriverUtilities.class);

    /***
     * Resets the implicit wait to the default value of the framework i.e. 30 seconds
     * @param driver     Instantiated object of webDriver
     */
    public void resetImplicitWaitToDefault(WebDriver driver) {
        driver.manage().timeouts().implicitlyWait(DEFAULT_TIMEOUT, TimeUnit.SECONDS);
    }

    /**
     * Clicks an element via javascript executor
     *
     * @param driver  Instantiated object of webDriver
     * @param element The element to click
     */
    public void jsClick(WebDriver driver, WebElement element) {
        logger.info("jsClick started with element \"" + element + "\"");
        String mouseOverScript = "arguments[0].click();";
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            js.executeScript(mouseOverScript, element);
        } catch (Exception e) {
            Assert.fail("FAIL: Clicking an element with JS executor FAILED with error: " + e);
        }
        logger.info("jsClick completed with element \"" + element + "\"");
    }

    /***
     * Scrolls an element into view (bottom of element will align with bottom of page) via javascript executor
     *
     * @param driver  Instantiated object of webDriver
     * @param element The element to scroll into view
     */
    public void jsScrollToElement(WebDriver driver, WebElement element) {
        logger.info("jsScrollToElement started with element \"" + element + "\"");
        String mouseOverScript = "arguments[0].scrollIntoView(false);";
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            js.executeScript(mouseOverScript, element);
        } catch (Exception e) {
            logger.info("jsScrollToElement encountered exception: " + e);
        }
        logger.info("jsScrollToElement completed with element \"" + element + "\"");
    }

    /**
     * Moves/scrolls to passed element such that the bottom of the element is aligned with bottom of page and clicks
     * the element using JS
     *
     * @param driver  Instantiated object of webDriver
     * @param element The element to move to and click
     */
    public void jsMoveToElementClick(WebDriver driver, WebElement element) {
        logger.info("jsMoveToElementClick started with element \"" + element + "\"");
        jsScrollToElement(driver, element);
        jsClick(driver, element);
        logger.info("jsMoveToElementClick completed with element \"" + element + "\"");
    }

    /**
     * Clicks an element with By selector and text
     *
     * @param driver Instantiated object of webDriver
     * @param by     By selector of element with text
     * @param text   Text of element to click on
     */
    public void clickElementWithText(WebDriver driver, By by, String text) {
        logger.info("clickElementWithText started");
        boolean found = false;
        try {
            List<WebElement> elements = driver.findElements(by);
            for (WebElement element : elements) {

                if (element.getText().toLowerCase().contains(text.toLowerCase())) {
                    found = true;
                    try {
                        element.click();
                    } catch (Exception e) {
                        jsClick(driver, element);
                    }
                    break;
                }
            }
        } catch (NoSuchElementException e) {
            Assert.fail("FAIL: Element \"" + by.toString() + "\" NOT found! (Full Stack Trace: " + e.toString() + ")");
        }

        if (!found)
            Assert.fail("FAIL: Element \"" + by.toString() + "\" with text \"" + text + "\" NOT found!");
        logger.info("clickElementWithText completed");
    }

    /**
     * Selects option from bootstrap dropdown
     *
     * @param elementId The id of option list
     * @param value     The value to select
     */
    public void selectDropDownValue(WebDriver driver, String elementId, String value) {
        logger.info("selectDropDownValue started");

        String js = "$('#" + elementId + "').trigger('mousedown');";
        JavascriptExecutor jse = (JavascriptExecutor) driver;

        try {
            waitForElementClickable(driver, driver.findElement(By.id(elementId)));
            WebElement webEle = driver.findElement(By.id(elementId));
            jsScrollToElement(driver, webEle);
            jse.executeScript(js);

            //If no underlying "li" tags are found, trying finding "option" tags
            List<WebElement> options = webEle.findElements(By.tagName("li"));
            if (options.size() == 0) {
                options = webEle.findElements(By.tagName("option"));
            }

            for (WebElement option : options) {
                if (option.getText().toLowerCase().contains(value.toLowerCase())) {
                    jsScrollToElement(driver, option);
                    option.click();
                    break;
                }
            }
        } catch (Exception e) {
            Assert.fail("FAIL: Selecting value \"" + value + "\" from dropdown with ID \"" +
                    elementId + "\" FAILED with error: " + e);
        }
        logger.info("selectDropDownValue completed");
    }

    /**
     * Returns element among multiple that contains text substring, if substring not found
     * returns null
     *
     * @param elementBy The By element to build list with
     * @param value     The value to search for with element
     * @param attempts  The number of attempts (seconds) to wait before attempting to find the element with text
     * @return WebElement
     */
    public WebElement getElementWithText(WebDriver driver, By elementBy, String value, int attempts) throws InterruptedException {
        logger.info("getElementWithText started looking for element \"" +
                elementBy + "\" with value \"" + value + "\"");
        WebElement returnElement = null;

        for (int i = 0; i < attempts; i++) {
            List<WebElement> elements = driver.findElements(elementBy);
            for (WebElement element : elements) {
                if (element.getText().toLowerCase().contains(value.toLowerCase())) {
                    returnElement = element;
                    break;
                }
            }

            if (returnElement != null)
                break;

            waitForMilliseconds(2000);
        }
        logger.info("getElementWithText completed looking for element \"" +
                elementBy + "\" with value \"" + value + "\"");
        return returnElement;
    }

    /**
     * Checks if element contains text string
     *
     * @param element By selector for element
     * @param text    Text element should contain
     * @return Boolean
     */
    public boolean checkIfElementContainsText(WebDriver driver, By element, String text) {
        logger.info("checkIfElementContainsText started");
        boolean found = false;
        List<WebElement> webElements = driver.findElements(element);
        for (WebElement webElement : webElements) {
            if (webElement.getText().toLowerCase().contains(text.toLowerCase())) {
                logger.info("Confirmed that the element contains '" + text + "'.");
                found = true;
                break;
            }
        }
        logger.info("checkIfElementContainsText completed");
        return found;
    }

    /**
     * Checks if element contains text string
     *
     * @param element By selector for element
     * @param text    Text element should contain
     * @return Boolean
     */
    public boolean checkIfElementContainsTextLowerCase(WebDriver driver, By element, String text) {
        logger.info("checkIfElementContainsTextLowerCase started");
        boolean found = false;
        List<WebElement> webElements = driver.findElements(element);
        for (WebElement webElement : webElements) {
            if (webElement.getText().toLowerCase().contains(text.toLowerCase())) {
                logger.info("Confirmed that the element contains '" + text + "'.");
                found = true;
                break;
            }
        }
        logger.info("checkIfElementContainsTextLowerCase completed");
        return found;
    }

    /**
     * Checks if element contains text string
     *
     * @param element WebElement to check
     * @param text    Text element should contain
     * @return Boolean
     */
    public boolean checkIfElementContainsText(WebElement element, String text) {
        logger.info("checkIfElementContainsText started");
        boolean found = false;
        if (element.getText().contains(text)) {
            logger.info("Confirmed that the element contains '" + text + "'.");
            found = true;
        }
        logger.info("checkIfElementContainsText completed");
        return found;
    }

    /**
     * Checks if text is displayed
     *
     * @param text The string text to check
     * @return boolean
     */
    public boolean
    isTextPresentInPageSource(WebDriver driver, String text) {
        return driver.getPageSource().contains(text);
    }

    /**
     * Waits until the element is clickable.
     * Note: Uses a max wait time of 30 seconds
     *
     * @param driver    Instantiated object of webDriver
     * @param byElement The element to wait for
     */
    public void waitForElementClickable(WebDriver driver, By byElement) {
        waitForElementClickable(driver, driver.findElement(byElement), DEFAULT_TIMEOUT);
    }

    /**
     * Waits until the element is clickable.
     * Note: Uses a variable max wait time
     *
     * @param driver        Instantiated object of webDriver
     * @param byElement     The element to wait for
     * @param timeInSeconds Integer representing the max wait time in seconds
     */
    public void waitForElementClickable(WebDriver driver, By byElement, long timeInSeconds) {
        waitForElementClickable(driver, driver.findElement(byElement), timeInSeconds);
    }

    /**
     * Waits until the element is clickable.
     * Note: Uses a max wait time of 30 seconds
     *
     * @param driver  Instantiated object of webDriver
     * @param element The element to wait for
     */
    public void waitForElementClickable(WebDriver driver, WebElement element) {
        waitForElementClickable(driver, element, DEFAULT_TIMEOUT);
    }

    /**
     * Waits specified number of seconds until the element is clickable.
     *
     * @param driver        Instantiated object of webDriver
     * @param element       The element to wait for
     * @param timeInSeconds Integer representing the max wait time in seconds
     */
    public void waitForElementClickable(WebDriver driver, WebElement element, long timeInSeconds) {
        logger.info("waitForElementClickable started.");
        driver.manage().timeouts().implicitlyWait(0, TimeUnit.SECONDS);

        Wait wait = new FluentWait(driver)
                .withTimeout(timeInSeconds, TimeUnit.SECONDS)
                .pollingEvery(POLLING_TIME_ONE_SECOND, TimeUnit.SECONDS)
                .ignoring(NoSuchElementException.class);

        try {
            wait.until(ExpectedConditions.elementToBeClickable(element));
        } catch (TimeoutException e) {
            Assert.fail("FAIL: Element \"" + element + "\" NOT found in \"" + timeInSeconds
                    + "\" seconds! " + "(Full Stack Trace: " + e.toString() + ")");
        }

        resetImplicitWaitToDefault(driver);
        logger.info("waitForElementClickable completed and found element \"" + element + "\"");
    }

    /**
     * Waits until the execution of the javascript returns with true.
     *
     * @param driver           Instantiated object of webDriver
     * @param javaScript       The javascript to be executed
     * @param timeOutInSeconds The time in seconds to wait until returning a failure
     * @return boolean
     */
    public boolean pollUntil(WebDriver driver, final String javaScript, long timeOutInSeconds) {
        logger.info("pollUntil started with a max wait of \"" + timeOutInSeconds + "\" seconds");
        boolean jsCondition = false;
        try {
            driver.manage().timeouts().implicitlyWait(0, TimeUnit.SECONDS);
            (new WebDriverWait(driver, timeOutInSeconds)).until(new ExpectedCondition<Boolean>() {
                @Override
                public Boolean apply(WebDriver driverObject) {
                    return (Boolean) ((JavascriptExecutor) driverObject).executeScript(javaScript);
                }
            });
            jsCondition = (Boolean) ((JavascriptExecutor) driver).executeScript(javaScript);
            driver.manage().timeouts().implicitlyWait(DEFAULT_TIMEOUT, TimeUnit.SECONDS);
            return jsCondition;
        } catch (Exception e) {
            logger.info("pollUntil error condition caught: " + e.toString());
        }
        logger.info("pollUntil completed with a max wait of \"" + timeOutInSeconds + "\" seconds");
        return jsCondition;
    }

    /**
     * Wait for the Text to be present in the given element, regardless of being displayed or not.
     *
     * @param driver        Instantiated object of webDriver
     * @param by            Selector of the given element, which should contain the text
     * @param text          The text we are looking for
     * @param timeInSeconds The time in seconds to wait until returning a failure
     * @return boolean
     */
    public boolean waitForTextPresent(WebDriver driver, final By by, final String text, long timeInSeconds) {
        logger.info("waitForTextPresent started with max wait of \"" + timeInSeconds + "\" seconds");

        boolean isPresent = false;
        driver.manage().timeouts().implicitlyWait(0, TimeUnit.SECONDS);
        Wait wait = new FluentWait(driver)
                .withTimeout(timeInSeconds, TimeUnit.SECONDS)
                .pollingEvery(POLLING_TIME_ONE_SECOND, TimeUnit.SECONDS)
                .ignoring(NoSuchElementException.class);

        try {
            wait.until(ExpectedConditions.textToBePresentInElementLocated(by, text));
            isPresent = true;
        } catch (TimeoutException e) {
            //TODO: Leaving in place in case we wish to refactor to move the assertion here
            //Assert.fail("FAIL: Element \"" + getByValue(by) + "\" did not contain \"" + text + "\" in \"" + time
            //        + "\" seconds! " + "(Full Stack Trace: " + e.toString() + ")");
        }
        resetImplicitWaitToDefault(driver);
        logger.info("waitForTextPresent completed - '" + text + "' was " + isPresent);
        return isPresent;
    }

    /**
     * Wait for the Text to be present in the given element. Text case is ignored.
     *
     * @param driver Instantiated object of webDriver
     * @param by     Selector of the given element, which should contain the text
     * @param text   The text we are looking for
     * @param time   The time in seconds to wait until returning a failure
     * @return boolean
     */
    public boolean waitForTextPresentIgnoreCase(WebDriver driver, final By by, final String text, long time) {
        logger.info("waitForTextPresentIgnoreCase started with max wait of \"" + time + "\" seconds");
        int counter = 0;
        boolean isPresent = false;
        try {
            do {
                isPresent = StringUtils.containsIgnoreCase(driver.findElement(by).getText(), text);
                counter++;
            } while (counter < time && !isPresent);
        } catch (TimeoutException e) {
            //TODO: Leaving in place in case we wish to refactor to move the assertion here
            //Assert.fail("FAIL: Element \"" + getByValue(by) + "\" did not contain \"" + text + "\" in \"" + time
            //        + "\" seconds! " + "(Full Stack Trace: " + e.toString() + ")");
        }
        logger.info("waitForTextPresentIgnoreCase completed - '" + text + "' was " + isPresent);
        return isPresent;
    }

    /**
     * Waits for a specific class to be present on the page, using pollUntil
     *
     * @param driver    Instantiated object of webDriver
     * @param className The name of the class to poll for
     * @param time      The time to wait
     */
    public void waitForClassPresent(WebDriver driver, String className, long time) {
        String script = "return document.getElementsByClassName('" + className + "')[0] != null;";
        if (pollUntil(driver, script, time)) {
            logger.info("className " + className + " found.");
        } else {
            Assert.fail("FAIL: className " + className + " NOT found.");
        }
    }

    /**
     * Pulls the text value from a By element
     *
     * @param by The by element to pull the value from
     * @return String  The extracted value
     */
    public String getByValue(By by) {
        String byString = by.toString();
        return byString.substring(byString.lastIndexOf(": ") + 2);
    }

    /**
     * Waits for page to load within default timeout
     *
     * @param driver Instantiated object of webDriver
     */
    public void waitForPageToLoad(WebDriver driver) {
        logger.info("waitForPageToLoad started");
        pollUntil(driver, "return document.readyState.indexOf('complete')>-1;", DEFAULT_TIMEOUT);
        logger.info("waitForPageToLoad completed");
    }

    /**
     * Checks if an attribute is present in an element
     *
     * @param driver    Instantiated object of webDriver
     * @param element   The by element to check
     * @param attribute The attribute to look for
     * @return boolean     Whether the attribute was present or not
     */
    public boolean isAttributePresent(WebDriver driver, WebElement element, String attribute) {
        logger.info("isAttributePresent started");
        driver.manage().timeouts().implicitlyWait(0, TimeUnit.SECONDS);
        Boolean result = false;
        try {
            String value = element.getAttribute(attribute);
            if (value != null) {
                resetImplicitWaitToDefault(driver);
                result = true;
            }
        } catch (Exception e) {
            logger.info("isAttributePresent threw error:" + e);
        }
        logger.info("isAttributePresent started");
        resetImplicitWaitToDefault(driver);
        return result;
    }

    /**
     * Sleeps for set time to allow for animation to complete.
     */
    public void waitForMilliseconds(int ms) throws InterruptedException {
        logger.info("waitForMilliseconds started with wait time of \"" + ms + "\" ms");
        Thread.sleep(ms);
        logger.info("waitForMilliseconds completed with wait time of\"" + ms + "\" ms");
    }

    /**
     * Method to wait till indication becomes Invisible
     *
     * @param driver     Instantiated object of webDriver
     * @param element    WebElement to poll for it's visibility
     * @param timeToWait The time to wait
     */
    public void waitTillElementIsVisible(WebDriver driver, WebElement element, long timeToWait) {
        WebDriverWait wait = new WebDriverWait(driver, timeToWait);
        wait.until(ExpectedConditions.invisibilityOf(element));
    }

    /**
     * Method to wait till indication becomes Invisible
     *
     * @param driver     Instantiated object of webDriver
     * @param by         By to poll for it's visibility
     * @param timeToWait The time to wait
     */
    public void waitTillElementIsVisible(WebDriver driver, By by, long timeToWait) {
        WebDriverWait wait = new WebDriverWait(driver, timeToWait);
        wait.until(ExpectedConditions.invisibilityOf(driver.findElement(by)));
    }


    /**
     * @param driver
     * @param byElement
     * @return
     */
    public WebElement waitForElementPresent(WebDriver driver, By byElement) {
        Wait<WebDriver> wait = new FluentWait<WebDriver>(driver).withTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS).pollingEvery(POLLING_TIME_ONE_SECOND, TimeUnit.SECONDS).ignoring(NoSuchElementException.class);

        WebElement webElement = wait.until(new Function<WebDriver, WebElement>() {
            public WebElement apply(WebDriver driver) {
                return driver.findElement(byElement);
            }
        });
        return webElement;
    }

    /**
     * @param driver
     * @param byElement
     * @return
     */
    public Select selectByDropDownValue(WebDriver driver, By byElement) {
        Select dropdownElement = new Select(driver.findElement(byElement));
        return dropdownElement;
    }

    public Select selectByDropDownValueWebElement(WebDriver driver, WebElement element) {
        Select dropdownElement = new Select(element);
        return dropdownElement;
    }


    /**
     * Calendar Popup window handler
     *
     * @param driver
     * @param calendarWebElement
     * @param date
     */
    public void handleCalendarPopup(WebDriver driver, WebElement calendarWebElement, String date) {
        JavascriptExecutor javascriptExecutor = (JavascriptExecutor) driver;
        String dateScriptPlaceholder = "arguments[0].setAttribute('placeholder','" + date + "');";
        javascriptExecutor.executeScript(dateScriptPlaceholder, calendarWebElement);
    }

    /**
     * Click the webElement
     *
     * @param driver
     * @param webElement
     */
    public void click(WebDriver driver, WebElement webElement) {
        JavascriptExecutor javascriptExecutor = (JavascriptExecutor) driver;
        javascriptExecutor.executeScript("arguments[0].click();", webElement);
    }


    /**
     * @param webElementService
     */
    public static void selectCheckBox(WebElement webElementService) {
        if (!webElementService.isSelected()) {
            webElementService.click();
        }
    }

    /**
     * @param webElementService
     */
    public static void unSelectCheckBox(WebElement webElementService) {
        if (webElementService.isSelected()) {
            webElementService.click();
        }
    }

    /**
     * @param element
     * @return
     */
    public static boolean isElementPresent(WebElement element) {
        try {
            if (element.isDisplayed()) {
                return true;
            }
        } catch (NoSuchElementException e) {
            return false;
        } catch (TimeoutException e) {
            return false;
        }
        return true;
    }

    /**
     * @param driver
     * @param byLinkText
     * @return
     */
    public boolean isElementPresent(WebDriver driver, By byLinkText) {
        try {
            WebElement element = driver.findElement(byLinkText);
            if (element.isDisplayed()) {
                return true;
            }
        } catch (NoSuchElementException e) {
            return false;
        } catch (TimeoutException e) {
            return false;
        }
        return true;
    }

    /**
     * @param driver
     * @param parentMenu
     * @param childMenu
     */
    public void onMouseHoverAction(WebDriver driver, WebElement parentMenu, WebElement childMenu) {
        Actions action = new Actions(driver);
        action.moveToElement(parentMenu).perform();
        action.moveToElement(childMenu).click().build().perform();
    }

    /**
     * @param driver
     * @param parentMenuLinkText
     * @param childMenuLinkText
     */
    public void onMouseHoverAction(WebDriver driver, By parentMenuLinkText, By childMenuLinkText) {
        Actions action = new Actions(driver);
        action.moveToElement(driver.findElement(parentMenuLinkText)).perform();
        action.moveToElement(driver.findElement(childMenuLinkText)).click().build().perform();
    }

    /**
     * @param driver
     * @param parentMenuLinkText
     * @param childMenuLinkText
     */
    public boolean verifySubMenuDisplayed(WebDriver driver, By parentMenuLinkText, By childMenuLinkText) {
        Actions action = new Actions(driver);
        action.moveToElement(driver.findElement(parentMenuLinkText)).perform();
        DriverCommand.takeScreenshot("Parent Menu Hover Link is Focused & the Sub Menu is displayed");
        if (isElementPresent(driver, childMenuLinkText)) {
            return true;
        }
        return false;
    }

    /**
     * <p>The below snippet mouseHoverWithScreenShot to be removed once onmousehoveraction is modified</p>
     *
     * @param driver
     * @param parentMenu
     * @param childMenu
     * @param screenShotDescription
     * @param currentTestCaseName
     */
    public void mouseHoverWithScreenShot(WebDriver driver, WebElement parentMenu, WebElement childMenu, String screenShotDescription, String currentTestCaseName) {
        Actions action = new Actions(driver);
        action.moveToElement(parentMenu).perform();
        DriverCommand.takeScreenshot(screenShotDescription, currentTestCaseName);
        action.moveToElement(childMenu).click().build().perform();
    }

    /**
     * Different way of handling the wait until element present
     *
     * @param driver
     * @param webElement
     * @param timeout
     * @return
     */
    public WebElement waitForElementPresent(WebDriver driver, WebElement webElement, long timeout) {
        WebDriverWait wait = new WebDriverWait(driver, timeout);
        WebElement element = wait.until(ExpectedConditions.visibilityOf(webElement));
        return element;
    }

    /**
     * Switch between parent-child windows for validations
     *
     * @param Head
     * @param header
     * @param driver
     */
    public void windowHandler(String Head, WebElement header, WebDriver driver) {
        String parentHandle = driver.getWindowHandle();
        logger.info("Parent Handle: " + parentHandle);
        String childWindowHandle = "";
        // Get all handles
        Set<String> handles = driver.getWindowHandles();
        // Switching between handles
        for (String handle : handles) {
            logger.info("Current Executing Test Case Name {" + DriverCommand.getThreadTestName() + "} Current Handles -> " + handle);
            if (!handle.equals(parentHandle)) {
                driver.switchTo().window(handle);
                logger.info("Current Executing Test Case Name {" + DriverCommand.getThreadTestName() + "} Current Window Titles " + driver.getTitle());
                if (driver.getTitle().equalsIgnoreCase(Head)) {
                    childWindowHandle = handle;

                    DriverCommand.takeScreenshot("Switch to " + Head + " Page");
                    break;
                }
            }
        }
        waitForElementPresent(driver, header, DEFAULT_TIMEOUT);
        header.isDisplayed();
        // Switch back to the parent window

        logger.info("Switching back to Parent Window");

        driver.switchTo().window(parentHandle);
        DriverCommand.takeScreenshot("Switch to Parent Window Page - Test Evidence");
        logger.info("Current Executing Test Case Name {" + DriverCommand.getThreadTestName() + "} Current Window Closed - Handle Name -> " + childWindowHandle);
    }

    /**
     * Waits for the JQUery processing to complete on element to display & enable to perform the actions
     * <p>
     * JQuery Processing
     *
     * @param webDriver
     * @param timeOutInSeconds
     */
    public void waitForJQueryProcessing(final WebDriver webDriver, int timeOutInSeconds) {
        new WebDriverWait(webDriver, timeOutInSeconds) {
        }.until(new ExpectedCondition<Boolean>() {
            @Override
            public Boolean apply(WebDriver driver) {
                return (Boolean) ((JavascriptExecutor) driver).executeScript("return window.jQuery != undefined && jQuery.active == 0");
            }
        });
    }

    /**
     * Waits for the Dom to be loaded
     *
     * @param webDriver
     * @param timeOutInSeconds
     */
    public void waitForDOMPageLoad(final WebDriver webDriver, int timeOutInSeconds) {
        new WebDriverWait(webDriver, timeOutInSeconds).until(new ExpectedCondition<Boolean>() {
            @Override
            public Boolean apply(WebDriver driver) {
                return ((JavascriptExecutor) driver).executeScript("return document.readyState").equals("complete") || ((JavascriptExecutor) driver).executeScript("return document.readyState").equals("interactive");
            }
        });
    }

    /**
     * Different way of handling the wait until element present
     *
     * @param driver
     * @param by
     * @param timeout
     * @return
     */
    public WebElement waitForPresenceOfElement(WebDriver driver, By by, int timeout) {
        WebDriverWait wait = new WebDriverWait(driver, timeout);
        WebElement element = wait.until(ExpectedConditions.presenceOfElementLocated(by));
        return element;
    }

    /**
     * Waits for Page to load
     *
     * @param driver
     */
    public void waitForPageLoad(WebDriver driver) {
        ExpectedCondition<Boolean> pageLoadCondition = new ExpectedCondition<Boolean>() {
            public Boolean apply(WebDriver driver) {
                return ((JavascriptExecutor) driver).executeScript("return document.readyState").equals("complete");
            }
        };
        WebDriverWait wait = new WebDriverWait(driver, DEFAULT_TIMEOUT);
        wait.until(pageLoadCondition);
    }

    /**
     * Refresh page object based on the element
     *
     * @param driver
     * @param locator
     * @return
     */
    public static WebElement refreshObject(WebDriver driver, By locator) {
        try {
            return (driver.findElement(locator));
        } catch (StaleElementReferenceException e) {
            return refreshObject(driver, locator);
        }
    }

}
