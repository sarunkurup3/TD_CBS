package com.svb.core;

import com.svb.drivers.DriverCommand;
import com.svb.drivers.DriverManager;
import com.svb.drivers.DriverUtilities;
import com.svb.factory.CustomPageFactory;
import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.junit.Assert;
import org.openqa.selenium.*;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;

/**
 * Common Actions For -
 * <p>
 * Assertions
 * Browser based Actions
 * Element Validations
 *
 * @author anarora
 */

public class CommonActions {

    WebDriver driver;
    DriverUtilities driverUtils;
    private static Logger logger = LogManager.getLogger(CommonActions.class);

    private long DEFAULT_TIMEOUT = 30;
    private long FIVE_SEC_WAIT = 5;
    private long POLLING_TIME_ONE_SECOND = 1;
    private long POLLING_TIME = 10;

    public static final By headerBy = By.tagName("h1");

    public static final By ptagNameBy = By.tagName("p");

    public static final By spanTagNameBy = By.tagName("span");

    public static final By headerSecondBy = By.tagName("h2");

    public static final By buttonBy = By.tagName("button");

    public static final By inputBy = By.tagName("input");

    public static final By divBy = By.tagName("div");

    public static final By optionTagBy = By.className("active-result");

    public static final By anchorTagBy = By.tagName("a");

    public static final By imgTagBy = By.tagName("img");

    public CommonActions() {
        driver = DriverManager.getDriver();
        CustomPageFactory.initElements(driver, this);
        driverUtils = new DriverUtilities();
    }

    /**
     * Simulates clicking the 'back' browser navigation button
     *
     * @param driver Instantiated object of webDriver
     */
    public void browserNavigateBackAction(WebDriver driver) {
        logger.info("browserNavigateBackAction started");
        try {
            driver.navigate().back();
        } catch (Exception e) {
            ((JavascriptExecutor) driver).executeScript("history.go(-1)");
        }
        driverUtils.waitForPageToLoad(driver);
        logger.info("browserNavigateBackAction completed");
    }

    /**
     * Simulates clicking the 'back' browser navigation button
     */
    public void browserNavigateBackAction() {
        logger.info("browserNavigateBackAction started");
        try {
            if (OperatingSystemUtil.getOS().equals("mac")) {
                ((JavascriptExecutor) driver).executeScript("history.go(-1)");
            } else
                driver.navigate().back();
        } catch (Exception e) {
            Assert.fail("FAIL: Navigating back in the browser FAILED with error: " + e);
        }
        driverUtils.waitForPageToLoad(driver);
        logger.info("browserNavigateBackAction completed");
    }

    /**
     * Switch to Already Opened Next Browser Tab
     */
    public void switchToNextOpenedTab() {
        logger.info("switchToNextOpenedTab started");
        String mainHandle = driver.getWindowHandle();
        //TODO: This seems to wait for 5 seconds regardless
        new WebDriverWait(driver, FIVE_SEC_WAIT).until(ExpectedConditions.numberOfWindowsToBe(2));
        Set allHandles = driver.getWindowHandles();
        Iterator iter = allHandles.iterator();
        while (iter.hasNext()) {
            String popupHandle = iter.next().toString();
            if (!popupHandle.contains(mainHandle)) {
                driver.switchTo().window(popupHandle);
            }
        }
        logger.info("switchToNextOpenedTab completed");
    }

    /**
     * Switch to Previous Opened Browser Tab
     */
    public void switchToPreviousOpenedTab() {
        logger.info("switchToPreviousOpenedTab started");
        new WebDriverWait(driver, FIVE_SEC_WAIT).until(ExpectedConditions.numberOfWindowsToBe(2));
        ArrayList<String> tab = new ArrayList<String>(driver.getWindowHandles());
        if (tab.size() > 1) {
            driver.switchTo().window(tab.get(1));
            driver.close();
            driver.switchTo().window(tab.get(0));
        } else {
            logger.info("Previous Browser Tab Not Found");
        }
        logger.info("switchToPreviousOpenedTab completed");
    }

    /**
     * Closes all tabs or windows except the main handle
     */
    public void closeTabs() {
        logger.info("closeTabs started");

        Set allHandles = driver.getWindowHandles();
        String mainHandle = driver.getWindowHandle();

        Iterator iter = allHandles.iterator();
        while (iter.hasNext()) {
            String popupHandle = iter.next().toString();
            if (!popupHandle.contains(mainHandle)) {
                driver.switchTo().window(popupHandle);
                driver.close();
                driver.switchTo().window(mainHandle);
            }
        }
        logger.info("closeTabs completed");
    }

    /**
     * Asserts that the expected header is displayed on the page
     *
     * @param header The header (h1 element text) of the page
     */
    public void assertPageHeader(String header) {
        logger.info("assertPageHeader started");

        //TODO CCL - need to address issue w/ Safari; Safari appears to bring in extra chars and spacing that .trim()
        //TODO CCL (cont) and regex removal patterns seem to be ineffective in removing
        driverUtils.waitForPageToLoad(driver);
        String actualHeader = driver.findElement(headerBy).getText();

        Assert.assertTrue("FAIL: The expected page header '" + header + "' was NOT contained in the"
                + " actual header '" + actualHeader + "'!", actualHeader.trim().toLowerCase().contains(
                header.trim().toLowerCase()));
        logger.info("Confirmed that the page header is \"" + header + "\".");

        logger.info("assertPageHeader completed");
    }

    /**
     * Asserts that the expected 2nd lvl header is displayed on the page
     *
     * @param text The header (h2 element text) of the page
     */
    public void assertPageSecondLevelHeader(String text) throws InterruptedException {
        logger.info("assertPageSecondLevelHeader started");
        driverUtils.waitForTextPresent(driver, headerSecondBy, text, FIVE_SEC_WAIT);

        Set allHandles = driver.getWindowHandles();
        String mainHandle = driver.getWindowHandle();
        int count = allHandles.size();

        if (count == 1) {
            Assert.assertTrue("FAIL: \"" + text + "\" was NOT displayed on the page!",
                    driverUtils.checkIfElementContainsText(driver, headerSecondBy, text));
        } else {
            Iterator iter = allHandles.iterator();
            while (iter.hasNext()) {
                String popupHandle = iter.next().toString();
                if (!popupHandle.contains(mainHandle)) {
                    driver.switchTo().window(popupHandle);
                    Assert.assertTrue("FAIL: \"" + text + "\" was NOT displayed on the page!",
                            driverUtils.checkIfElementContainsText(driver, headerSecondBy, text));
                    driver.switchTo().window(mainHandle);
                }
            }
        }
        logger.info("Confirmed that the element contains \"" + text + "\".");
        logger.info("assertPageSecondLevelHeader completed");
    }

    /**
     * Asserts that the expected text is displayed on the page
     *
     * @param by           The By element of the page
     * @param textToSearch The header (subtext) of the page
     */
    public void assertPageElementTextByElement(By by, String textToSearch) {
        logger.info("assertPageElementTextByElement started");
        Set allHandles = driver.getWindowHandles();
        String mainHandle = driver.getWindowHandle();
        int count = allHandles.size();
        if (count == 1) {
            Assert.assertTrue("FAIL: \"" + textToSearch + "\" was NOT displayed on the page!",
                    driverUtils.checkIfElementContainsText(driver, by, textToSearch));
        } else {
            Iterator iter = allHandles.iterator();
            while (iter.hasNext()) {
                String popupHandle = iter.next().toString();
                if (!popupHandle.contains(mainHandle)) {
                    driver.switchTo().window(popupHandle);
                    Assert.assertTrue("FAIL: \"" + textToSearch + "\" was NOT displayed on the page!",
                            driverUtils.checkIfElementContainsTextLowerCase(driver, by, textToSearch));
                    driver.switchTo().window(mainHandle);
                }
            }
        }
        logger.info("Confirmed that the element contains \"" + textToSearch + "\".");
        logger.info("assertPageElementTextByElement completed");
    }

    /**
     * Asserts whether the current page title matches or not
     *
     * @param title The Title (title element text) of the page
     */
    public void assertPageTitle(String title) {
        logger.info("assertPageTitle started");
        int time = (int) DEFAULT_TIMEOUT;
        String script = "return document.getElementsByTagName('title')[0].textContent.indexOf('" + title + "')>-1;";
        boolean foundTitle = driverUtils.pollUntil(driver, script, time);
        Assert.assertTrue("FAIL: Title \"" + title + "\" was NOT displayed in \"" + time + "\" seconds!",
                foundTitle);
        logger.info("Confirmed that the page title is \"" + title + "\".");
        logger.info("assertPageTitle completed");
    }

    /**
     * Returns element among multiple that contains text substring, if substring not found
     * returns first
     *
     * @param by   The element to check
     * @param text The text to check
     */
    public void assertElementWithTextIsVisible(By by, String text) throws InterruptedException {
        logger.info("assertTextPresentInElement started");
        if (driverUtils.getElementWithText(driver, by, text, 2) == null) {
            Assert.fail("FAIL: Element \"" + by.toString() + "\" with text \"" + text + "\" NOT present!");
        } else {
            Assert.assertTrue("FAIL: Unable to find a displayed element with By = \"" + by
                            + "\" and text = \"" + text + "\"!",
                    driverUtils.getElementWithText(driver, by, text, 2).isDisplayed());
        }
        logger.info("assertTextPresentInElement ended - Line item \"" + text + "\" is present");
    }

    /**
     * Checks if text is displayed
     *
     * @param text The string text to check
     */
    public void assertTextPresentInPageSource(String text) {
        logger.info("assertTextPresentInPageSource started with text \"" + text + "\"");
        Assert.assertTrue("FAIL: Text: \"" + text + "\" - was NOT present!",
                driverUtils.isTextPresentInPageSource(driver, text));
        logger.info("Text: \"" + text + "\" - was present");
        logger.info("assertTextPresentInPageSource completed with text \"" + text + "\"");
    }

    /**
     * Verify whether the specified button is enabled or disabled
     *
     * @param buttonText        - the text on the button to be validated
     * @param enabledOrDisabled - expected state of 'enabled' or 'disabled'
     */
    public void assertButtonEnabledDisabled(String buttonText, String enabledOrDisabled) throws InterruptedException {
        logger.info("assertButtonEnabledDisabled started");
        boolean found = false;
        WebElement button;

        try {
            button = driverUtils.getElementWithText(driver, buttonBy, buttonText, 4);
        } catch (Exception e) {
            button = driverUtils.getElementWithText(driver, inputBy, buttonText, 4);

        }
        if (button.getText().equals(buttonText)) {
            if (enabledOrDisabled.equalsIgnoreCase("ENABLED")) {
                Assert.assertTrue("The submit button was disabled when it was expected to be enabled", button.isEnabled());
            } else {
                Assert.assertTrue("The submit button was enabled when it was expected to be disabled", !button.isEnabled());
            }
            found = true;
        }

        Assert.assertTrue(buttonText + " button not found", found);
        logger.info("assertButtonEnabledDisabled completed");
    }

    /**
     * Clicks button containing certain text
     *
     * @param text Value of the button to be clicked
     */
    public void clickButtonByText(String text) {
        By button = By.tagName("button");
        logger.info("clickButtonByText started with text = \"" + text + "\"");
        driverUtils.clickElementWithText(driver, button, text);
        logger.info("clickButtonByText completed with text = \"" + text + "\"");
    }

    /**
     * Waits for url to contain path
     *
     * @param path    The path of the url to wait for
     * @param seconds Integer of seconds for driver wait
     */
    public void waitForUrl(final String path, int seconds) {
        logger.info("waitForUrl started");
        WebDriverWait wait = new WebDriverWait(driver, seconds);
        ExpectedCondition e = new ExpectedCondition<Boolean>() {
            public Boolean apply(WebDriver d) {
                return (d.getCurrentUrl().contains(path));
            }
        };

        try {
            wait.until(e);
        } catch (Exception exception) {
            Assert.fail("FAIL: Url after \"" + seconds + "\" seconds remained \"" + driver.getCurrentUrl() +
                    "\" and never ended up containing \"" + path + "\"!");
        }
        logger.info("Confirmed that current URL now contains '" + path + "'.");
        logger.info("waitForUrl completed");
    }

    /**
     * Returns the h1 header of the page
     *
     * @return String
     */
    public String getPageHeader() {
        return driver.findElement(headerBy).getText();
    }

    /**
     * Verifies the expected attributes (strings) are contained within a specified section (By object)
     *
     * @param pageSection            Name of the page section
     * @param sectionHeaderBy        By object for the section of the page containing the attributes to be verified
     * @param expectedAttributesList List of attribute values expected to be contained with the specified page section
     */
    public void verifyPageSectionContainsAttributes(String pageSection, By sectionHeaderBy,
                                                    List<String> expectedAttributesList) throws InterruptedException {
        logger.info("verifyPageSectionContainsAttributes started for section: '" + pageSection
                + "'\n\t\twith expected attributes: '" + expectedAttributesList + "'");
        String compareSectionContent = driverUtils.getElementWithText(driver, sectionHeaderBy, pageSection, 3).getText();
        for (String attribute : expectedAttributesList) {
            Assert.assertTrue("FAIL - The page section '" + pageSection
                            + "' did NOT contain the expected attribute of: '" + attribute + "'!",
                    compareSectionContent.contains(attribute));
        }
        logger.info("verifyPageSectionContainsAttributes completed successfully for section: '"
                + pageSection + "'");
    }

    /**
     * Get the X coordinate value of an element
     *
     * @param by The element in reference
     * @return int     X coordinate value of an element
     */
    public int getXCoordinateValueOfAnElement(By by) {
        logger.info("getXCoordinateValueOfAnElement started");
        driverUtils.waitForElementPresent(driver, by);

        int xCoordinateValue = Integer.valueOf(driver.findElement(by).getLocation().toString().split(",")[0].split("\\(")[1]);
        logger.info("getXCoordinateValueOfAnElement completed");
        return xCoordinateValue;
    }

    /**
     * Verifies the checkbox with specified label has been selected
     *
     * @param element       WebElement for the checkbox
     * @param checkboxLabel String of the checkbox label
     */
    public void verifyCheckboxSelected(WebElement element, String checkboxLabel) {
        logger.info("verifyCheckboxSelected started for checkbox w/ label: \"" + checkboxLabel + "\"");
        driverUtils.waitForPageToLoad(driver);
        Assert.assertTrue("FAIL: checkbox with label: \"" + checkboxLabel + "\" was NOT selected!",
                element.isSelected());
        logger.info("verifyCheckboxSelected completed - checkbox w/ label: \"" + checkboxLabel
                + "\" was selected!");
    }

    /**
     * Verifies linktext is displayed on homepage
     *
     * @param linktext - 'linktext' link to validate
     */
    public void verifyLinkIsDisplayedOnPage(String linktext) throws InterruptedException {
        logger.info("verifyLinkIsDisplayedOnPage started for link " + linktext);
        driverUtils.waitForPageToLoad(driver);
        if (!(driverUtils.getElementWithText(driver, anchorTagBy, linktext, 2)).isDisplayed()) {
            Assert.fail("FAIL : Link " + linktext + " did NOT display on the page");
        }
        logger.info("verifyLinkIsDisplayedOnPage completed for link " + linktext);
    }

    public void highlightElement(WebElement element) throws InterruptedException {
        try {
            driverUtils.waitForMilliseconds(500);
            JavascriptExecutor js = (JavascriptExecutor) driver;
            js.executeScript("arguments[0].setAttribute('style', arguments[1]);",
                    element, "color: red; border: 5px solid red;");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        driverUtils.waitForMilliseconds(500);
    }

    public void highlightElement(WebElement element, String color) throws InterruptedException {
        try {
            driverUtils.waitForMilliseconds(500);
            JavascriptExecutor js = (JavascriptExecutor) driver;
            js.executeScript("arguments[0].setAttribute('style', arguments[1]);",
                    element, "color: " + color + "; border: 5px solid " + color + ";");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        driverUtils.waitForMilliseconds(500);
    }
}
